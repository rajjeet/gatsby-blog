---
title: Refactoring for Breakthroughs 
dateCreated: 2019-09-13
dateModified: 2019-09-29
draft: false
author: Rajjeet
category: Insights
image: './anthony-tori-9qYKMbBCFjc-unsplash.jpg'
description: Upfront designing of software is not easy, especially for large unpredictable projects. Refactoring and testing play a key for maturing codebases.    
tags:
    - Testing
---
### Premature Design
Even in an agile workplace, senior developers and architects still design software solutions upfront before digging into code. There are many problems that can’t be anticipated with planning. They must be handled as they arrive. 

Big architectural designs made before gain working experience of the codebase can lead teams down the wrong path. Time is wasted reverting the changes later on.

### Healthy Organic Software
So, here is the key insight. Instead of forcing an ideal design upfront, let the codebase evolve organically. This can bring the best result with the least effort.

![I only code organically (image by Igor Son via Unsplash.com)](igor-son-FV_PxCqgtwc-unsplash.jpg)

Evolve Organically? Is the codebase a plant? No. By Evolving organically, I’m referring to progressive refactoring. Refactoring is the art of changing structure without touching behaviour. 

### Codebase Veteran
Development time tends to bounce between writing new code and refactoring old code. We refactor code because it:
* makes code easy to understand 
* prepares code for anticipated changes
* reduces duplication of logic 
* improves algorithmic efficiency 

Good refactorings add value and experience. Add up enough experience via refactorings over time and developers naturally connect the dots that lead to breakthrough redesigns. The nuances behind these breakthroughs happen due to many factors. This  include frustrations, conversations, research, repeated exposure, and pattern recognition encountered during the development process. 

![I've been with this codebase for years. I'll lead the charge. (image by Daniel Ioanu via unsplash.com)](daniel-ioanu-jjGupGhhqDc-unsplash.jpg)

### Risky Refactoring
These refactoring are great and should be encouraged but they entail the risk of regression, when previously working code breaks. That’s why test-driven development (TDD) is a MUST for safe refactorings. 

### Red Green Refactor
TDD in a nutshell. Write a little test. Write enough code to make it pass. Refactor the code. Rinse and repeat. 

With good tests, you refactor with confidence and boldness. You play with arrangements until you find one that works best for the moment. These refactorings are quick, simple, and enjoyable. You do this while adding functionality in bite sized pieces.

The tests act as safety nets. When you break code, you’re notified. You know what broke the code, thus avoid countless hours of headache. If you spend the time upfront writing good test, it saves time and cost when the codebase is much larger. 

With a growing codebase, breakthroughs help keep feature additions manageable. A large codebase has many moving parts, so it can be intimidating to change things. Having good tests reassures us that we can develop with piece of mind. 

### Closing Remarks
I've summarized these ideas in my own words from [James Shore's](https://www.jamesshore.com/) presentation at AssertJS 2019. From his presentation and my own experience with testing and refactoring, I wrote this blog post. I'm happy to hear your feedback. Thanks for reading.